package rails.game;import java.util.*;import org.w3c.dom.*;import rails.util.*;public class TileManager implements TileManagerI, ConfigurableComponentI{	protected static TileManagerI instance = null;	protected Map tileMap = new HashMap();	/**	 * No-args constructor.	 */	public TileManager()	{		instance = this;	}	public static TileManagerI get()	{		return instance;	}	/**	 * @see rails.game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)	 */	public void configureFromXML(Element seTop) throws ConfigurationException	{		/*		 * Note: prefix se is used for elements from TileSet.xml, prefix te for		 * elements from Tiles.xml.		 */		String teFileName = seTop.getAttribute("tiles");		if (teFileName == null)			throw new ConfigurationException(LocalText.getText("NoTilesXML"));		String teFilePath = "data/" + ComponentManager.getGameName() + "/"				+ teFileName;		Element teTop = XmlUtils.findElementInFile(teFilePath, "Tiles");		if (teTop == null)			throw new ConfigurationException(LocalText.getText("NoTilesTag"));		NodeList seList = seTop.getElementsByTagName("Tile");		NodeList teList = teTop.getElementsByTagName("Tile");		/*		 * The XML files TileSet.xml and Tiles.xml are read side by side, as		 * each one configures different tile aspects. The reason for having two		 * XML files is, that Tiles.xml defines per-tile aspects that are the		 * same for all games (such as the colour, tracks and stations; this		 * file is an automatically generated subset of the generic file		 * tiles/Tiles.xml), whereas TileSet.xml specifies the aspects that are		 * (or can be) specific to each rails.game (such as the possible upgrades).		 * <p>TileSet.xml is leading.		 */		Element se, te;		int tileId;		Integer id;		TileI tile;		// Creates maps to the tile definitions in both files.		Map seMap = new HashMap();		Map teMap = new HashMap();		for (int i = 0; i < seList.getLength(); i++)		{			id = new Integer(i);			se = (Element) seList.item(i);			tileId = XmlUtils.extractIntegerAttribute(se.getAttributes(), "id");			id = new Integer(tileId);			/*			 * Check for duplicates (this also covers missing tile ids, as this			 * returns 0, and we always have a tile numbered 0!			 */			if (seMap.containsKey(id))			{				throw new ConfigurationException(				        LocalText.getText("DuplicateTilesetID", String.valueOf(tileId)));			}			seMap.put(id, se);		}		for (int i = 0; i < teList.getLength(); i++)		{			te = (Element) teList.item(i);			tileId = XmlUtils.extractIntegerAttribute(te.getAttributes(), "id");			id = new Integer(tileId);			/*			 * Check for duplicates (this also covers missing tile ids, as this			 * returns 0, and we always have a tile numbered 0!			 */			if (teMap.containsKey(id))			{				throw new ConfigurationException(				        LocalText.getText("DuplicateTileID", String.valueOf(tileId)));			}			else if (!seMap.containsKey(id))			{				throw new ConfigurationException(				        LocalText.getText("TileMissingInTileSet", String.valueOf(tileId)));			}			teMap.put(id, te);		}		// Create the Tile objects (must be done before further parsing)		Iterator it = seMap.keySet().iterator();		while (it.hasNext())		{			id = (Integer) it.next();			tile = new Tile(id);			tileMap.put(id, tile);		}		// Finally, parse the <Tile> subtags		it = seMap.keySet().iterator();		while (it.hasNext())		{			id = (Integer) it.next();			tile = (TileI) tileMap.get(id);			tile.configureFromXML((Element) seMap.get(id),					(Element) teMap.get(id));		}	}	public TileI getTile(int id)	{		return (TileI) tileMap.get(new Integer(id));	}}