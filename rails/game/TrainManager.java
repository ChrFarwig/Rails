/* $Header: /Users/blentz/rails_rcs/cvs/18xx/rails/game/TrainManager.java,v 1.28 2010/04/21 21:25:50 evos Exp $ */package rails.game;import java.util.*;import org.apache.log4j.Logger;import rails.common.LocalText;import rails.common.parser.ConfigurableComponentI;import rails.common.parser.ConfigurationException;import rails.common.parser.Tag;import rails.game.move.ObjectMove;import rails.game.state.BooleanState;import rails.game.state.IntegerState;public class TrainManager implements ConfigurableComponentI {    // Static attributes    protected List<TrainType> lTrainTypes = new ArrayList<TrainType>();    protected Map<String, TrainType> mTrainTypes            = new HashMap<String, TrainType>();    protected List<TrainCertificateType> trainCertTypes             = new ArrayList<TrainCertificateType>();    protected Map<String, TrainCertificateType> trainCertTypeMap            = new HashMap<String, TrainCertificateType>();    protected Map<String, TrainI> trainMap            = new HashMap<String, TrainI>();        protected Map<TrainCertificateType, List<TrainI>> trainsPerCertType             = new HashMap<TrainCertificateType, List<TrainI>>();        protected TrainType defaultType = null; // Only required locally and in ChoiceType        private boolean removeTrain = false;        // Dynamic attributes    protected IntegerState newTypeIndex;        protected Map<String, Integer> lastIndexPerType = new HashMap<String, Integer>();    protected boolean trainsHaveRusted = false;    protected boolean phaseHasChanged = false;    protected boolean trainAvailabilityChanged = false;    protected List<PublicCompanyI> companiesWithExcessTrains;    protected GameManagerI gameManager = null;    protected Bank bank = null;        /** Required for the sell-train-to-foreigners feature of some games */    protected BooleanState anyTrainBought = new BooleanState ("AnyTrainBought", false);        // Triggered phase changes    protected Map<TrainCertificateType, Map<Integer, Phase>> newPhases            = new HashMap<TrainCertificateType, Map<Integer, Phase>>();    // Non-game attributes    protected Portfolio ipo, pool, unavailable;        // For initialisation only    boolean trainPriceAtFaceValueIfDifferentPresidents = false;    protected static Logger log =        Logger.getLogger(TrainManager.class.getPackage().getName());        /**     * No-args constructor.     */    public TrainManager() {        newTypeIndex = new IntegerState("NewTrainTypeIndex", 0);    }    /**     * @see rails.common.parser.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)     */    public void configureFromXML(Tag tag) throws ConfigurationException {                TrainType newType;        Tag defaultsTag = tag.getChild("Defaults");        // We will use this tag later, to preconfigure TrainCertType and TrainType.        List<Tag> typeTags;        // Choice train types (new style)        List<Tag> trainTypeTags = tag.getChildren("TrainType");        if (trainTypeTags != null) {            for (Tag trainTypeTag : trainTypeTags) {                TrainCertificateType certType = new TrainCertificateType();                if (defaultsTag != null) certType.configureFromXML(defaultsTag);                certType.configureFromXML(trainTypeTag);                trainCertTypes.add(certType);                trainCertTypeMap.put(certType.getName(), certType);                                // The potential train types                typeTags = trainTypeTag.getChildren("Train");                if (typeTags == null) {                    // That's OK, all properties are in TrainType, to let's reuse that tag                    typeTags = Arrays.asList(trainTypeTag);                }                for (Tag typeTag : typeTags) {                    newType = new TrainType();                    if (defaultsTag != null) newType.configureFromXML(defaultsTag);                    newType.configureFromXML(trainTypeTag);                    newType.configureFromXML(typeTag);                    lTrainTypes.add(newType);                    mTrainTypes.put(newType.getName(), newType);                    certType.addPotentialTrainType(newType);                }            }        }               // Special train buying rules        Tag rulesTag = tag.getChild("TrainBuyingRules");        if (rulesTag != null) {            // A 1851 special            trainPriceAtFaceValueIfDifferentPresidents = rulesTag.getChild("FaceValueIfDifferentPresidents") != null;        }        // Are trains sold to foreigners?        Tag removeTrainTag = tag.getChild("RemoveTrainBeforeSR");        if (removeTrainTag != null) {            // Trains "bought by foreigners" (1844, 1824)            removeTrain = true; // completed in finishConfiguration()        }            }    public void finishConfiguration (GameManagerI gameManager)    throws ConfigurationException {        this.gameManager = gameManager;        bank = gameManager.getBank();        ipo = bank.getIpo();        pool = bank.getPool();        unavailable = bank.getUnavailable();        // Finish initialisation of the train types        Map<Integer, String> rustedTrainTypeNames;        TrainCertificateType releasedType, rustedType;        for (TrainCertificateType type : trainCertTypes) {            if (type.getReleasedTrainTypeNames() != null) {                List<TrainCertificateType> rtts = new ArrayList<TrainCertificateType>(2);                for (String ttName : type.getReleasedTrainTypeNames().split(",")) {                    releasedType = trainCertTypeMap.get(ttName);                    if (releasedType == null) {                        throw new ConfigurationException ("Train type "+type.getName()+" releases undefined type "+ttName);                    }                    rtts.add (trainCertTypeMap.get(ttName));                }                type.setReleasedTrainTypes(rtts);                        }            rustedTrainTypeNames = type.getRustedTrainTypeNames();            if (rustedTrainTypeNames != null) {                for (int index : rustedTrainTypeNames.keySet()) {                    String ttName = rustedTrainTypeNames.get(index);                    rustedType = trainCertTypeMap.get(ttName);                    if (rustedType == null) {                        throw new ConfigurationException ("Train type "+type.getName()+" rusts undefined type "+ttName);                    }                    type.setRustedTrainType(index, rustedType);                    rustedType.setPermanent(false);                }            }        }                Map<Integer, String> newPhaseNames;        Phase phase;        String phaseName;        PhaseManager phaseManager = gameManager.getPhaseManager();                for (TrainCertificateType certType : trainCertTypes) {            certType.finishConfiguration(gameManager);                        List<TrainType> types = certType.getPotentialTrainTypes();            for (TrainType type : types) {                type.finishConfiguration(gameManager, certType);            }                        // Now create the trains of this type            TrainI train;            // Multi-train certificates cannot yet be assigned a type            TrainType initialType = types.size() == 1 ? types.get(0) : null;                        /* If the amount is infinite, only one train is created.             * Each time this train is bought, another one is created.             */            for (int i = 0; i < (certType.hasInfiniteQuantity() ? 1 : certType.getQuantity()); i++) {                train = certType.createTrain ();                train.init(certType, initialType, getNewUniqueId(certType.getName()));                addTrain(train);                unavailable.addTrain(train);            }                        // Register any phase changes            newPhaseNames = certType.getNewPhaseNames();            if (newPhaseNames != null && !newPhaseNames.isEmpty()) {                for (int index : newPhaseNames.keySet()) {                    phaseName = newPhaseNames.get(index);                    phase = (Phase)phaseManager.getPhaseByName(phaseName);                    if (phase == null) {                        throw new ConfigurationException ("New phase '"+phaseName+"' does not exist");                    }                    if (newPhases.get(certType) == null) newPhases.put(certType, new HashMap<Integer, Phase>());                    newPhases.get(certType).put(index, phase);                }            }        }        // By default, set the first train type to "available".        newTypeIndex.set(0);        makeTrainAvailable(trainCertTypes.get(newTypeIndex.intValue()));        // Trains "bought by foreigners" (1844, 1824)        if (removeTrain) {            gameManager.setGameParameter(GameDef.Parm.REMOVE_TRAIN_BEFORE_SR, true);        }                // Train trading between different players at face value only (1851)        gameManager.setGameParameter(GameDef.Parm.FIXED_PRICE_TRAINS_BETWEEN_PRESIDENTS,                trainPriceAtFaceValueIfDifferentPresidents);    }    /** Create train without throwing exceptions.     * To be used <b>after</b> completing initialization,     * i.e. in cloning infinitely available trains.     */    public TrainI cloneTrain (TrainCertificateType certType) {        TrainI train = null;        List<TrainType> types = certType.getPotentialTrainTypes();        TrainType initialType = types.size() == 1 ? types.get(0) : null;        try {            train = certType.createTrain();        } catch (ConfigurationException e) {            log.warn("Unexpected exception", e);        }        train.init(certType, initialType, getNewUniqueId(certType.getName()));        addTrain(train);        return train;    }    public void addTrain (TrainI train) {        trainMap.put(train.getUniqueId(), train);                TrainCertificateType type = train.getCertType();        if (!trainsPerCertType.containsKey(type)) {            trainsPerCertType.put (type, new ArrayList<TrainI>());        }        trainsPerCertType.get(type).add(train);    }    public TrainI getTrainByUniqueId(String id) {        return trainMap.get(id);    }        public String getNewUniqueId (String typeName) {        int newIndex = lastIndexPerType.containsKey(typeName) ? lastIndexPerType.get(typeName) + 1 : 0;        lastIndexPerType.put (typeName, newIndex);        return typeName + "_"+ newIndex;    }    /**     * This method handles any consequences of new train buying (from the IPO),     * such as rusting and phase changes. It must be called <b>after</b> the     * train has been transferred.     *     */    public void checkTrainAvailability(TrainI train, Portfolio from) {        trainsHaveRusted = false;        phaseHasChanged = false;        if (from != ipo) return;        TrainCertificateType boughtType, nextType;        boughtType = train.getCertType();        if (boughtType == (trainCertTypes.get(newTypeIndex.intValue()))            && ipo.getTrainOfType(boughtType) == null) {            // Last train bought, make a new type available.            newTypeIndex.add(1);            if (newTypeIndex.intValue() < lTrainTypes.size()) {                nextType = (trainCertTypes.get(newTypeIndex.intValue()));                if (nextType != null) {                    if (!nextType.isAvailable()) {                        makeTrainAvailable(nextType);                        trainAvailabilityChanged = true;                        ReportBuffer.add("All " + boughtType.getName()                                         + "-trains are sold out, "                                         + nextType.getName() + "-trains now available");                    }                }            }        }                int trainIndex = boughtType.getNumberBoughtFromIPO();        if (trainIndex == 1) {            // First train of a new type bought            ReportBuffer.add(LocalText.getText("FirstTrainBought",                    boughtType.getName()));            String newPhase = boughtType.getStartedPhaseName();            if (newPhase != null) {                gameManager.getPhaseManager().setPhase(newPhase, train.getHolder());                phaseHasChanged = true;            }            List<TrainCertificateType> releasedTypes = boughtType.getReleasedTrainTypes();            if (releasedTypes != null) {                for (TrainCertificateType releasedType : releasedTypes) {                    if (!releasedType.isAvailable()) {                        makeTrainAvailable(releasedType);                    ReportBuffer.add(LocalText.getText("TrainsAvailable",                        releasedType.getName()));                    }                }                trainAvailabilityChanged = true;            }        }                // New style phase changes, can be triggered by any bought train.        Phase newPhase;        if (newPhases.get(boughtType) != null                && (newPhase = newPhases.get(boughtType).get(trainIndex)) != null) {            gameManager.getPhaseManager().setPhase(newPhase, train.getHolder());            phaseHasChanged = true;        }        TrainCertificateType rustedType = boughtType.getRustedTrainType(trainIndex);        if (rustedType != null && !rustedType.hasRusted()) {            rustTrainType (rustedType, train.getHolder());             if (rustedType.isObsoleting()) {                ReportBuffer.add(LocalText.getText("TrainsObsolete",                        rustedType.getName()));            } else {                ReportBuffer.add(LocalText.getText("TrainsRusted",                    rustedType.getName()));            }            trainsHaveRusted = true;            trainAvailabilityChanged = true;        }    }        protected void makeTrainAvailable (TrainCertificateType type) {        type.setAvailable();        Portfolio to =            (type.getInitialPortfolio().equalsIgnoreCase("Pool") ? bank.getPool()                    : bank.getIpo());        for (TrainI train : trainsPerCertType.get(type)) {            new ObjectMove(train, unavailable, to);        }    }    protected void rustTrainType (TrainCertificateType type, Portfolio lastBuyingCompany) {        type.setRusted();        for (TrainI train : trainsPerCertType.get(type)) {            Portfolio holder = train.getHolder();            if (type.isObsoleting() && holder.getOwner() instanceof PublicCompanyI                    && holder != lastBuyingCompany) {                log.debug("Train " + train.getUniqueId() + " (owned by "                        + holder.getName() + ") obsoleted");                train.setObsolete();                holder.getTrainsModel().update();            } else {                log.debug("Train " + train.getUniqueId() + " (owned by "                        + holder.getName() + ") rusted");                train.setRusted();            }        }    }        public List<TrainI> getAvailableNewTrains() {        List<TrainI> availableTrains = new ArrayList<TrainI>();        TrainI train;        for (TrainCertificateType type : trainCertTypes) {            if (type.isAvailable()) {                train = ipo.getTrainOfType(type);                if (train != null) {                    availableTrains.add(train);                }            }        }        return availableTrains;    }    public String getTrainCostOverview() {        StringBuilder b = new StringBuilder();        for (TrainCertificateType certType : trainCertTypes) {            if (certType.getCost() > 0) {                if (b.length() > 1) b.append(" ");                b.append(certType.getName()).append(":").append(Bank.format(certType.getCost()));                if (certType.getExchangeCost() > 0) {                    b.append("(").append(Bank.format(certType.getExchangeCost())).append(")");                }            } else {                for (TrainType type : certType.getPotentialTrainTypes()) {                    if (b.length() > 1) b.append(" ");                    b.append(type.getName()).append(":").append(Bank.format(type.getCost()));                }            }        }        return b.toString();    }        public TrainType getTypeByName(String name) {        return mTrainTypes.get(name);    }    public List<TrainType> getTrainTypes() {        return lTrainTypes;    }    public List<TrainCertificateType> getTrainCertTypes() {        return trainCertTypes;    }        public TrainCertificateType getCertTypeByName (String name) {        return trainCertTypeMap.get(name);    }    public boolean hasAvailabilityChanged() {        return trainAvailabilityChanged;    }    public void resetAvailabilityChanged() {        trainAvailabilityChanged = false;    }    public boolean hasPhaseChanged() {        return phaseHasChanged;    }    public boolean isAnyTrainBought () {        return anyTrainBought.booleanValue();    }        public void setAnyTrainBought (boolean newValue) {        if (isAnyTrainBought() != newValue) {            anyTrainBought.set(newValue);        }    }}