/* $Header: /Users/blentz/rails_rcs/cvs/18xx/rails/game/TileManager.java,v 1.17 2010/05/29 09:38:58 stefanfrey Exp $ */package rails.game;import java.util.*;import org.apache.log4j.Logger;import rails.common.LocalText;import rails.common.parser.*;import rails.game.Stop.Loop;import rails.game.Stop.RunThrough;import rails.game.Stop.RunTo;import rails.game.Stop.Type;import rails.util.Util;public class TileManager implements ConfigurableComponentI {    protected Map<Integer, TileI> tileMap = new HashMap<Integer, TileI>();    protected List<Integer> tileIds = new ArrayList<Integer>();    //    private static List<String> directories = new ArrayList<String>();    private List<String> directories = new ArrayList<String>();    // Stop property defaults per stop type    protected Map<Type,RunTo> runToDefaults = new HashMap<Type, RunTo>();    protected Map<Type,RunThrough> runThroughDefaults = new HashMap<Type, RunThrough>();    protected Map<Type,Loop> loopDefaults = new HashMap<Type, Loop>();    protected static Logger log =        Logger.getLogger(TileManager.class.getPackage().getName());    /**     * No-args constructor.     */    public TileManager() {    }    /**     * @see rails.common.parser.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)     */    public void configureFromXML(Tag tileSetTop) throws ConfigurationException {        /*         * Note: prefix se is used for elements from TileSet.xml, prefix te for         * elements from Tiles.xml.         */        String tileDefFileName = tileSetTop.getAttributeAsString("tiles");        if (tileDefFileName == null)            throw new ConfigurationException(LocalText.getText("NoTilesXML"));        directories.add("data/" + GameManager.getInstance().getGameName());        Tag tileDefTop =            Tag.findTopTagInFile(tileDefFileName, directories, "Tiles");        if (tileDefTop == null)            throw new ConfigurationException(LocalText.getText("NoTilesTag"));        List<Tag> tileSetList = tileSetTop.getChildren("Tile");        List<Tag> tileDefList = tileDefTop.getChildren("Tile");        /*         * The XML files TileSet.xml and Tiles.xml are read side by side, as         * each one configures different tile aspects. The reason for having two         * XML files is, that Tiles.xml defines per-tile aspects that are the         * same for all games (such as the colour, tracks and stations; this         * file is an automatically generated subset of the generic file         * tiles/Tiles.xml), whereas TileSet.xml specifies the aspects that are         * (or can be) specific to each rails.game (such as the possible         * upgrades). <p>TileSet.xml is leading.         */        int tileId;        TileI tile;        // Creates maps to the tile definitions in both files.        Map<Integer, Tag> tileSetMap = new HashMap<Integer, Tag>();        Map<Integer, Tag> tileDefMap = new HashMap<Integer, Tag>();        for (Tag tileSetTag : tileSetList) {            tileId = tileSetTag.getAttributeAsInteger("id");            /*             * Check for duplicates (this also covers missing tile ids, as this             * returns 0, and we always have a tile numbered 0!             */            if (tileSetMap.containsKey(tileId)) {                throw new ConfigurationException(LocalText.getText(                        "DuplicateTilesetID", String.valueOf(tileId)));            }            tileSetMap.put(tileId, tileSetTag);            tileIds.add(tileId);        }        for (Tag tileDefTag : tileDefList) {            tileId = tileDefTag.getAttributeAsInteger("id");            /*             * Check for duplicates (this also covers missing tile ids, as this             * returns 0, and we always have a tile numbered 0!             */            if (tileDefMap.containsKey(tileId)) {                throw new ConfigurationException(LocalText.getText(                        "DuplicateTileID", String.valueOf(tileId)));            } else if (!tileSetMap.containsKey(tileId)) {                log.warn ("Tile #"+tileId+" exists in Tiles.xml but not in TileSet.xml (this can be OK if the tile only exists in some variants");            }            tileDefMap.put(tileId, tileDefTag);        }        // Create the Tile objects (must be done before further parsing)        for (Integer id : tileSetMap.keySet()) {            tile = new Tile(id);            tileMap.put(id, tile);        }        // Finally, parse the <Tile> subtags        for (Integer id : tileMap.keySet()) {            tile = tileMap.get(id);            tile.configureFromXML(tileSetMap.get(id), tileDefMap.get(id));        }        // Parse default stop types        Type type;        RunTo runTo;        RunThrough runThrough;        Loop loop;        String s;        Tag defaultsTag = tileSetTop.getChild("Defaults");        if (defaultsTag != null) {            List<Tag> accessTags = defaultsTag.getChildren("Access");            for (Tag accessTag : accessTags) {                // Type                s = accessTag.getAttributeAsString("type", null);                if (Util.hasValue(s)) {                    try {                        type = Type.valueOf(s.toUpperCase());                    } catch (IllegalArgumentException e) {                        throw new ConfigurationException ("Illegal value for default property type: "+s, e);                    }                } else {                    type = null; // For default defaults                }                // RunTo                s = accessTag.getAttributeAsString("runTo", null);                if (Util.hasValue(s)) {                    try {                        runTo = RunTo.valueOf(s.toUpperCase());                    } catch (IllegalArgumentException e) {                        throw new ConfigurationException ("Illegal value for "                                +type+" default runTo property: "+s, e);                    }                    runToDefaults.put(type, runTo);                }                // RunThrough                s = accessTag.getAttributeAsString("runThrough", null);                if (Util.hasValue(s)) {                    try {                        runThrough = RunThrough.valueOf(s.toUpperCase());                    } catch (IllegalArgumentException e) {                        throw new ConfigurationException ("Illegal value for "                                +type+" default runThrough property: "+s, e);                    }                    runThroughDefaults.put(type, runThrough);                }                // Loop                s = accessTag.getAttributeAsString("loop", null);                if (Util.hasValue(s)) {                    try {                        loop = Loop.valueOf(s.toUpperCase());                    } catch (IllegalArgumentException e) {                        throw new ConfigurationException ("Illegal value for "                                +type+" default loop property: "+s, e);                    }                    loopDefaults.put(type, loop);                }            }        }    }    public void finishConfiguration (GameManagerI gameManager)    throws ConfigurationException {        for (TileI tile : tileMap.values()) {            tile.finishConfiguration(this);        }    }    public TileI getTile(int id) {        return tileMap.get(id);    }    /** Get the tile IDs in the XML definition sequence */    public List<Integer> getTileIds() {        return tileIds;    }    /** returns the set of all possible upgrade tiles */    public List<TileI> getAllUpgrades(TileI tile, MapHex hex) {        TreeSet<TileI> tileSet = new TreeSet<TileI>();        return new ArrayList<TileI>(recursiveUpgrades(tile, hex, tileSet));    }    private TreeSet<TileI> recursiveUpgrades(TileI tile, MapHex hex, TreeSet<TileI> tileSet) {        tileSet.add(tile);        List<TileI> directUpgrades = tile.getAllUpgrades(hex);        for (TileI upgrade:directUpgrades)            if (!tileSet.contains(upgrade))                tileSet = recursiveUpgrades(upgrade, hex, tileSet);        return tileSet;    }    public RunTo getRunToDefault(Type type) {        return runToDefaults.containsKey(type) ? runToDefaults.get(type) : null;    }    public RunThrough getRunThroughDefault(Type type) {        return runThroughDefaults.containsKey(type) ? runThroughDefaults.get(type) : null;    }    public Loop getLoopDefault(Type type) {        return loopDefaults.containsKey(type) ? loopDefaults.get(type) : null;    }}